---
title: "Update on Bimodality Figures & Analyses"
author: "Kelly Heilman"
date: "January 10, 2017"
output: html_document
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Bimodality Figures
#Updated: January 10th, 2017

##Overall Distributions of density & tree cover
### We know that pls tree density is bimodal and fia tree density is not:
![PLS density](outputs/PLS_density_histogrom.png) 
![FIA density](outputs/FIA_density_histogram.png)

## PLS % canopy cover also appears slightly bimodal:
![PLS cover](outputs/v1.6/PLS_cover_histogrom.png)

##The past climate space of the Midwest is broad spans a large range of precipitation and temperature. Neither one of these parameters fully explains the distribution in tree density:
![Temperature vs Precip](outputs/v1.6/precip_vs_temp_full_pls.png)

#Progress to date on Key Bimodality paper Figures:

###Figure 1: PLS, FIA density and  % cover plotted as a function of precipitation, The density of overlapping points is displayed using shading by the "count". 
![PLS vs precip](outputs/PLS_full_precipitation_hexbin.png) 
![FIA vs precip](outputs/fia_precipitation_hexbin.png)
![% cover vs. precip](outputs/v1.6/PLS_cover_precipitation_hexbin.png)

###Figure 2: Bimodality Index for PLS and FIA (i.e. how bimodal the data is) in different sliding windows or different bins of precipitation (OR water balance OR Principal Component 1)
* Still working on calculating a “Bimodality index,” some options we may have for this:
  + Dip Test (null = unimodal distribution)
  + Bimodality Coefficient calculated from size, skewness, and kurtosis of the distributions, though there may be issues with both BC and the Dip test (Pfister et al. 2013)
  + BC > 0.556 suggests bimodality
  + BC can be calculated in the R package modes 

##Notably, looking at different binwidths of mean annual precipitation gives us a slightly different answer for the index of bimodality at each precipitation range:

##Bin range of 100, non-overlapping bins:
![PLS 100 bins](outputs/v1.6/bimodality_coefficient_full_pls_100bins.png) 

##Bin range of 75, non-overlapping bins:
![PLS 75 bins](outputs/v1.6/bimodality_coefficient_full_pls_75bins.png) 

##Bin range of 25, non-overlapping bins:
![PLS 25 bins](outputs/v1.6/bimodality_coefficient_full_pls_25bins.png) 

## Additionally, we can have overlapping bins, where each new "bin of precpitation" is offset by 10mm/year, which also present a slightly different picture.
##Bin range of 100, overlapping bins:
![PLS 100 bins](outputs/v1.6/rolling_BC_plots_100.png)
##Bin range of 75, overlapping bins:
![PLS 75 bins](outputs/v1.6/rolling_BC_plots_75.png)
##Bin range of 25, overlapping bins:
dev.off() 

we can do the same for FIA plots & cover (not shown here)

### Figure 3: Plot of Bimodality index vs. Density (not sure how to do this, since a high BC inherently means that we have both high and low densities)

### Figure 4:
We can make maps of the precipitation climate space where BC > 5.5 from the BC values of non-overlapping bins of width = 75mm in Figure 2:

# Map of bimodality for PLS:![PLS 75 bins](outputs/v1.6/PLS_BC_map_75.png)

# Map of bimodality for FIA:![PLS 75 bins](outputs/v1.6/FIA_BC_map_75.png)

# The map for PLS density bimodality does roughly match with the Map of bimodality for PLS % cover estimates (which makes sense)
![PLS 75 bins](outputs/v1.6/PLS_BC_cover_map75.png)

```{r, echo = FALSE}
library(shiny)
library(ggplot2)
library(reshape2)
library(dplyr)
library(maps)
library(maptools)
library(modes)
dens.pr <- read.csv("outputs/v1.6/dens.pr.csv")

all_states <- map_data("state")
states <- subset(all_states, region %in% c(  'minnesota','wisconsin','michigan',"illinois",  'indiana') )
coordinates(states)<-~long+lat
class(states)
proj4string(states) <-CRS("+proj=longlat +datum=NAD83")
mapdata<-spTransform(states, CRS('+init=epsg:3175'))
mapdata <- data.frame(mapdata)

cbpalette <- c("#ffffcc", "#c2e699", "#78c679", "#31a354", "#006837")


#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#

library(shiny)

# Define UI for application that draws a histogram
ui <- shinyUI(fluidPage(
   
   # Application title
   titlePanel("PLS density"),
   
   # Sidebar with a slider input for number of bins 
   sidebarLayout(
      sidebarPanel(
         sliderInput("bins",
                     "Number of bins:",
                     min = 1,
                     max = 50,
                     value = 30),
      
        sliderInput("precip",
                      "Precipitation",
                      min = 200,
                      max = 1350,
                      value = c(200,1350)),

      
        sliderInput("sand",
                      "Sand Percentage",
                     min = 0,
                     max = 100,
                    value = c(0,100)),
        sliderInput("BC_interval",
                    "Bimodality Coefficient Binwidth",
                    min = 0,
                    max = 1150,
                    value = 150)
   
      ),
      # Show a plot of the generated distribution
      mainPanel(
         plotOutput("distPlot"),
         #plotOutput('densityPlot'),
         plotOutput('mapPlot'),
         plotOutput('precipPlot'),
         plotOutput('bimodalPlot')
         
      )
   )
)
)


# Define server logic required to draw a histogram
server <- shinyServer(function(input, output) {
   
   output$distPlot <- renderPlot({
      # generate bins based on input$bins from ui.R
      
      filtered <-
        dens.pr %>%
        filter(MAP1910 >= input$precip[1],
               MAP1910 <= input$precip[2],
               sandpct >= input$sand[1],
               sandpct <= input$sand[2]
        )
      x    <- filtered$PLSdensity 
      bins <- seq(min(x), max(x), length.out = input$bins + 1)
      
      # draw the histogram with the specified number of bins
      hist(x, probability = TRUE ,breaks = bins, col = 'darkgray', border = 'white')
      lines(density(x), col = 'darkblue')
         
    
   }) 
   output$precipPlot <- renderPlot({
     # generate bins based on input$bins from ui.R
     
     filtered <-
       dens.pr %>%
       filter(MAP1910 >= input$precip[1],
              MAP1910 <= input$precip[2],
              sandpct >= input$sand[1],
              sandpct <= input$sand[2]
       )
    
     
     # draw the histogram with the specified number of bins
     ggplot(filtered, aes(MAP1910, PLSdensity))+geom_point()
     
     
   }) 
   output$mapPlot <- renderPlot({
     # generate bins based on input$bins from ui.R
     
     filtered <-
       dens.pr %>%
       filter(MAP1910 >= input$precip[1],
              MAP1910 <= input$precip[2],
              sandpct >= input$sand[1],
              sandpct <= input$sand[2]
       )
     cbPalette <- c("#999999","#009E73", "#E69F00", "#56B4E9",  "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
     ggplot()+ geom_polygon(data = mapdata, aes(group = group,x=long, y =lat), fill = 'darkgrey')+
       geom_raster(data=filtered, aes(x=x, y=y, fill = PLSdensity))+
       geom_polygon(data = mapdata, aes(group = group,x=long, y =lat),colour="black", fill = NA)+
       labs(x="easting", y="northing", title="PLS tree density") + 
       scale_fill_gradientn(colours = cbpalette, limits = c(0,700), name ="Tree \n Density \n (trees/hectare)", na.value = 'darkgrey') +
       coord_equal()+theme_bw()
     
     
   }) 
   output$densityPlot <- renderPlot({filtered <-
     dens.pr %>%
     filter(MAP1910 >= input$precip[1],
            MAP1910 <= input$precip[2],
            sandpct >= input$sand[1],
            sandpct <= input$sand[2]
     )
   plot(density(filtered$PLSdensity, kernel="gaussian"), col = 'blue')
   lines(density(filtered$PLSdensity, kernal = 'biweight'), col = 'grey')
   
   })
   
   output$bimodalPlot <- renderPlot({filtered <-
     dens.pr %>%
     filter(MAP1910 >= input$precip[1],
            MAP1910 <= input$precip[2],
            sandpct >= input$sand[1],
            sandpct <= input$sand[2]
     )
      
      ordered <- filtered[order(filtered$MAP1910),]
      
      rollBC_by_10_r = function(x,y,xout,width) {
        out = 1:length(seq(200, 1350, by = 10) )
        for( i in 1:length(seq(200, 1350, by = 10))) {
          window = x >= (xout[i]-width) & x <= (xout[i]+width)
          out[i] = bimodality_coefficient( y[window] )
        }
        ggplot()+geom_point(aes(x = xout, y = out))+
          geom_hline( yintercept = 5/9)+ylim(0,1)+theme_bw()+
          xlab('interval center') + ylab('Bimodality Coefficient') +ggtitle(paste0( 'Bimodality coefficient for binwidth = ', width))
      }   
      
      rollBC_by_10_r(ordered$MAP1910, ordered$PLSdensity, seq(200, 1350, by = 10) , input$BC_interval)
})
   output$bimodalMAP <- renderPlot({filtered <-
     dens.pr %>%
     filter(MAP1910 >= input$precip[1],
            MAP1910 <= input$precip[2],
            sandpct >= input$sand[1],
            sandpct <= input$sand[2]
     )
   
   ordered <- filtered[order(filtered$MAP1910),]
   
   rollBC_by_10_r = function(x,y,xout,width) {
     out = 1:length(seq(200, 1350, by = 10) )
     for( i in 1:length(seq(200, 1350, by = 10))) {
       window = x >= (xout[i]-width) & x <= (xout[i]+width)
       out[i] = bimodality_coefficient( y[window] )
     }
     
     
     ggplot()+geom_point(aes(x = xout, y = out))+
       geom_hline( yintercept = 5/9)+ylim(0,1)+theme_bw()+
       xlab('interval center') + ylab('Bimodality Coefficient') +ggtitle(paste0( 'Bimodality coefficient for binwidth = ', width))
   }   
   
   rollBC_r(ordered$MAP1910, ordered$PLSdensity, seq(200, 1350, by = 10) , input$BC_interval)
   })
})
# Run the application 
shinyApp(ui = ui, server = server)


```